<!DOCTYPE html><html><head><meta charset="utf-8"><title>Publish live reliable actor telemetry from service fabric | Naeem Khedarun</title><meta name="author" content="Naeem Khedarun"><meta name="description" content="After you&#39;ve got your service fabric application live, you might see performance issues which you didn&#39;t pick up in testing or simulated load tests."><meta name="viewport" content="width=device-width,initial-scale=1"><meta property="og:title" content="Publish live reliable actor telemetry from service fabric"><meta property="og:site_name" content="Naeem Khedarun"><meta property="og:image" content="http://naeem.khedarun.co.uk/blog/images/code-cover.png"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://naeem.khedarun.co.uk/blog/images/code-cover.png"><meta property="og:description" content="After you&#39;ve got your service fabric application live, you might see performance issues which you didn&#39;t pick up in testing or simulated load tests."><meta name="twitter:description" content="After you&#39;ve got your service fabric application live, you might see performance issues which you didn&#39;t pick up in testing or simulated load tests."><meta property="og:url" content="http://naeem.khedarun.co.uk/blog/blog/2016/01/18/publish-live-reliable-actor-telemetry-from-service-fabric-1453119939817/"><meta name="twitter:site" content="@NaeemKhedarun"><meta name="twitter:creator" content="@NaeemKhedarun"><meta name="twitter:title" content="Publish live reliable actor telemetry from service fabric"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16.png"><link rel="alternate" href="/blog/atom.xml" title="Naeem Khedarun" type="application/atom+xml"><link rel="stylesheet" href="/css/all-de3b3b87da.min.css"><script type="text/javascript" src="https://www.google.com/jsapi?autoload={'modules':[{'name':'visualization','version':'1','packages':['corechart']}]}"></script></head><body><div id="wrap"><div class="navbar navbar-static-top" role="navigation"><div class="container"><div class="col-12 navbar-center"><a href="/blog/"><span class="name-brand">Naeem Khedarun</span></a> <span class="navbar-spacer"></span> <span><a href="https://twitter.com/naeemkhedarun"><i class="fa fa-twitter"></i></a> <a href="https://github.com/naeemkhedarun"><i class="fa fa-github"></i></a> <a href="https://uk.linkedin.com/in/naeemkhedarun"><i class="fa fa-linkedin-square"></i></a> <a href="/blog/atom.xml"><i class="fa fa-rss"></i></a></span></div></div></div><div class="container"><div class="row"><div class="col-12 col-md-12"><h1 class="title">Publish live reliable actor telemetry from service fabric</h1><i>a year ago</i><p></p><p>After you’ve got your service fabric application live, you might see performance issues which you didn’t pick up in testing or simulated load tests. This could be for a number of reasons.</p><ul><li>Unexpected actor bottleneck, they are <a href="https://azure.microsoft.com/en-gb/documentation/articles/service-fabric-reliable-actors-introduction/#concurrency" target="_blank" rel="external">single threaded</a>.</li><li>Time spent waiting on a bottlenecked actor.</li><li>Large state affecting IO performance.</li></ul><p>Reliable actors do not yet have interception interfaces to add in this kind of detailed telemetry, but with careful code its possible to do this with a dynamic proxy. I chose to use <a href="http://www.lightinject.net/#interception" target="_blank" rel="external">LightInject</a> for this but most of the framework would do the same job. I use statsd and graphite as my telemetry platform and I’ve had good experiences with <a href="https://github.com/Pereingo/statsd-csharp-client" target="_blank" rel="external">this nuget package</a></p><p>We need to intercept object on both sides of the network boundary to cover these scenarios.</p><ul><li>Service fabrics initialisation to trace <em>OnLoadStateAsync</em>, <em>OnActivateAsync</em>, etc…</li><li>Fabric client initialisation to trace client interface calls <em>IActorInterface.YourDoWorkMethodAsync</em>.</li></ul><p>We can trace the former by using service fabrics dependency injection support to initialise the actors with a proxy inbetween. First we override fabrics initialisation to use our DI container which has dynamic proxy support.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><div class="line">fabricRuntime.RegisterActorFactory(() =&gt; </div><div class="line">    ServiceLocator.Current.GetInstance&lt;YourActor&gt;());</div></pre></td></tr></table></figure><p>Next we tell our DI container to resolve these types with a proxy that includes our telemetry interceptor.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><div class="line">serviceRegistry.Intercept(registration =&gt; </div><div class="line">    <span class="keyword">typeof</span>(IActor).IsAssignableFrom(registration.ServiceType),</div><div class="line">    (factory, definition) =&gt;</div><div class="line">    &#123;</div><div class="line">        definition.Implement(factory.GetInstance&lt;ActorInterceptor&gt;);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure><p>This will catch the timings for any calls to actors made by the fabric system. Now we need to get the timings for all the calls we make, both <em>actor to actor</em> and <em>client to actor</em>.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActorFactory</span> : <span class="title">IActorFactory</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">readonly</span> ActorInterceptor _actorInterceptor;</div><div class="line">    <span class="keyword">readonly</span> ConcurrentDictionary&lt;Type, Type&gt; _proxies = </div><div class="line">        <span class="keyword">new</span> ConcurrentDictionary&lt;Type, Type&gt;();</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ActorFactory</span>(<span class="params">ActorInterceptor actorInterceptor</span>)</span></div><div class="line">    &#123;</div><div class="line">        _actorInterceptor = actorInterceptor;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> T Get&lt;T&gt;(ActorId actorId) <span class="keyword">where</span> T : IActor</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> proxyType = _proxies.GetOrAdd(<span class="keyword">typeof</span>(T), type =&gt;</div><div class="line">            <span class="keyword">new</span> ProxyBuilder().GetProxyType(</div><div class="line">                <span class="keyword">new</span> ProxyDefinition(<span class="keyword">typeof</span>(T), <span class="literal">true</span>).Implement(</div><div class="line">                    () =&gt; _actorInterceptor)));</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (T)Activator.CreateInstance(proxyType, </div><div class="line">            <span class="keyword">new</span> Lazy&lt;T&gt;(() =&gt; ActorProxy.Create&lt;T&gt;(actorId)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Above we’ve created a factory class which should be used by clients and actors to create the proxied ActorProxies. We cache the generated proxy types in a thread safe dictionary as they are <a href="http://naeem.khedarun.co.uk/blog/2016/01/18/a-look-at-performance-on-dotnet-dynamic-proxies-1448894394346/">expensive to create</a>.</p><p>Lastly we need the intercetor itself. We need to be sympathetic towards:</p><ul><li>All actor calls return a Task.</li><li>Avoid blocking calls by calling <code>Result</code> or <code>Wait</code> on the task.</li></ul><p>We can use a task continuation to handle the writing of telemetry together with a closure to capture the timer. If there is a return value we should return it, and for whatever reason that value is not a Task then we won’t try to add the continuation.</p><figure class="highlight csharp"><table><tr><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ActorInterceptor</span> : <span class="title">IInterceptor</span></div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">Invoke</span>(<span class="params">IInvocationInfo invocationInfo</span>)</span></div><div class="line">    &#123;</div><div class="line">        <span class="keyword">var</span> name = <span class="keyword">string</span>.Format(<span class="string">"Actors.&#123;0&#125;.&#123;1&#125;"</span>,</div><div class="line">            invocationInfo.Proxy.Target.GetType().Name,</div><div class="line">            invocationInfo.Method.Name);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> timer = Metrics.StartTimer(name);</div><div class="line"></div><div class="line">        <span class="keyword">var</span> returnValue = invocationInfo.Proceed();</div><div class="line"></div><div class="line">        (returnValue <span class="keyword">as</span> Task)?.ContinueWith(task =&gt;</div><div class="line">        &#123;</div><div class="line">           timer.Dispose();</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> returnValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>If you have your metrics library configured to push to a graphite backend you can use the following query to graph it:</p><figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">stats.timers.actors.*.*.mean</div><div class="line">stats.timers.actors.*.*.count</div></pre></td></tr></table></figure><p><img src="/blog/images/actor-telemetry.png" alt="actor telemetry"></p><p></p><div class="categories"><span>Posted in: </span><a href="/blog/categories/development/">development</a></div><div class="tags"><span>Tagged with: </span><a href="/blog/tags/NET/">.NET</a>, <a href="/blog/tags/C/">C#</a>, <a href="/blog/tags/azure/">azure</a>, <a href="/blog/tags/servicefabric/">servicefabric</a></div><br><hr><div class="row"><div class="col-md-12"><h3>Comments</h3><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div></div></div></div></div></div><div id="push"></div></div><div id="footer"><div class="container"><div class="container"><br><p class="muted credit">&copy; 2017 Naeem Khedarun</p></div></div></div><script src="/js/all-8d7c4a0adc.min.js"></script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-71815871-1', 'auto');
ga('send', 'pageview');</script><script type="text/javascript">var disqus_shortname = 'naeemkhedarun';
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());</script></body></html>