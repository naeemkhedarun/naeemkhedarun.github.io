<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Naeem Khedarun]]></title>
  
  <link href="/blog/atom.xml" rel="self"/>
  <link href="http://naeem.khedarun.co.uk/blog/"/>
  <updated>2016-01-15T12:08:57.000Z</updated>
  <id>http://naeem.khedarun.co.uk/blog/</id>
  
  <author>
    <name><![CDATA[Naeem Khedarun]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Getting the number of service fabric partitions]]></title>
    <link href="http://naeem.khedarun.co.uk/blog/2016/01/14/Getting-the-number-of-service-fabric-partitions-1452789246119/"/>
    <id>http://naeem.khedarun.co.uk/blog/2016/01/14/Getting-the-number-of-service-fabric-partitions-1452789246119/</id>
    <published>2016-01-14T16:34:19.000Z</published>
    <updated>2016-01-15T12:08:57.000Z</updated>
    <content type="html"><![CDATA[<p>You might need to programmatically lookup details about a service. The FabricClient class can be used to lookup various things from the cluster.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fabricClient = <span class="keyword">new</span> FabricClient();</span><br><span class="line"><span class="keyword">var</span> partitions = <span class="keyword">await</span> fabricClient.QueryManager.GetPartitionListAsync(</span><br><span class="line">    <span class="keyword">new</span> Uri($<span class="string">"fabric:/App/&#123;serviceName&#125;"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> partition = partitions[<span class="number">0</span>] <span class="comment">//Select the first partition;</span></span><br><span class="line"><span class="keyword">var</span> partitionLowKey = ((Int64RangePartitionInformation)partition.PartitionInformation).LowKey;</span><br></pre></td></tr></table></figure>
<p>The result of <code>GetPartitionListAsync</code> should never change for a service as you can’t change the partition information after a service has been created. It would be safe and give better performance to cache this. </p>
<p>The endpoint of the primary replica however can move between machines, so this does need to be resolved more frequently. You can also cache this if you have a retry strategy that will re-resolve after an <code>EndpointNotFoundException</code>.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> resolver = <span class="keyword">new</span> ServicePartitionResolver(() =&gt; fabricClient);</span><br><span class="line"><span class="keyword">var</span> resolvedPartition = <span class="keyword">await</span> resolver.ResolveAsync(<span class="keyword">new</span> Uri($<span class="string">"fabric:/App/&#123;serviceName&#125;"</span>), partitionLowKey, CancellationToken.None);</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>You might need to programmatically lookup details about a service. The FabricClient class can be used to lookup various things from the c]]>
    </summary>
    
      <category term=".NET" scheme="http://naeem.khedarun.co.uk/blog/tags/NET/"/>
    
      <category term="C#" scheme="http://naeem.khedarun.co.uk/blog/tags/C/"/>
    
      <category term="azure" scheme="http://naeem.khedarun.co.uk/blog/tags/azure/"/>
    
      <category term="servicefabric" scheme="http://naeem.khedarun.co.uk/blog/tags/servicefabric/"/>
    
      <category term="development" scheme="http://naeem.khedarun.co.uk/blog/categories/development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Sharding data across service fabric partitions]]></title>
    <link href="http://naeem.khedarun.co.uk/blog/2016/01/14/sharding-data-across-service-fabric-partitions-1452597860697/"/>
    <id>http://naeem.khedarun.co.uk/blog/2016/01/14/sharding-data-across-service-fabric-partitions-1452597860697/</id>
    <published>2016-01-14T14:58:24.000Z</published>
    <updated>2016-01-15T12:08:22.000Z</updated>
    <content type="html"><![CDATA[<p>Service fabric gives you two mechanisms out of the box when resolving which partition you hit when calling a Reliable Service. We’ll ignore the singleton partitions as they won’t help us with sharding.</p>
<ul>
<li><strong>Named Partition</strong> - This is a fixed name for each partition configured at deploy time.</li>
<li><strong>Ranged Partition</strong> - This uses an <code>Int64</code> range to decide which partition a numbered key falls in.</li>
</ul>
<p>More information can be found <a href="https://azure.microsoft.com/en-gb/documentation/articles/service-fabric-concepts-partitioning/" target="_blank" rel="external">here</a>.</p>
<h3 id="Named_Partitioning">Named Partitioning</h3><p>A named partition allows you to specify explicitly which partition you want to access at runtime. A common example is to specify A-Z named partitions and use the first letter of your data as the key. This splits your data into 26 partitions. </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Service</span> <span class="attribute">Name</span>=<span class="value">"TestService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">StatefulService</span> <span class="attribute">ServiceTypeName</span>=<span class="value">"TestServiceType"</span> </span><br><span class="line">                   <span class="attribute">TargetReplicaSetSize</span>=<span class="value">"3"</span> </span><br><span class="line">                   <span class="attribute">MinReplicaSetSize</span>=<span class="value">"2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">NamedPartition</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Partition</span> <span class="attribute">Name</span>=<span class="value">"a"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">Partition</span> <span class="attribute">Name</span>=<span class="value">"b"</span>/&gt;</span></span><br><span class="line">      ...</span><br><span class="line">      <span class="tag">&lt;<span class="title">Partition</span> <span class="attribute">Name</span>=<span class="value">"z"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">NamedPartition</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">StatefulService</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>The advantages to this are that it is simple and you know which partition your data goes in without a lookup. Unfortunately as we will test later, you are unlikely to get a good distribution of your data across the partitions.</p>
<h3 id="Ranged_Partitioning">Ranged Partitioning</h3><p>With a ranged partition the fabric tooling by default uses the entire <code>Int64</code> range as keys to decide which partition. It will then convert these into ranges or buckets depending on the partition count.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Service</span> <span class="attribute">Name</span>=<span class="value">"TestService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">StatefulService</span> <span class="attribute">ServiceTypeName</span>=<span class="value">"TestServiceType"</span> </span><br><span class="line">                   <span class="attribute">TargetReplicaSetSize</span>=<span class="value">"3"</span> </span><br><span class="line">                   <span class="attribute">MinReplicaSetSize</span>=<span class="value">"2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">UniformInt64Partition</span> <span class="attribute">PartitionCount</span>=<span class="value">"26"</span></span><br><span class="line">                           <span class="attribute">LowKey</span>=<span class="value">"-9223372036854775808"</span> </span><br><span class="line">                           <span class="attribute">HighKey</span>=<span class="value">"9223372036854775807"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">StatefulService</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>However to be able to lookup a partition we need a function which can reduce our data to an integer value. To use the configuration above we can convert our strings into an <code>Int64</code>. </p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> md5 = MD5.Create();</span><br><span class="line"><span class="keyword">var</span> <span class="keyword">value</span> = md5.ComputeHash(Encoding.ASCII.GetBytes(<span class="keyword">value</span>));</span><br><span class="line"><span class="keyword">var</span> key = BitConverter.ToInt64(<span class="keyword">value</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> client = ServiceProxy.Create&lt;ITestService&gt;(</span><br><span class="line">                    key, </span><br><span class="line">                    <span class="keyword">new</span> Uri(<span class="string">"fabric:/App/TestService"</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li>Hash the value to a fixed length byte array.</li>
<li>Convert the array to an <code>Int64</code>.</li>
<li>Create the client with the calculated key to connect to the service on that partition.</li>
</ol>
<h3 id="Ranged_Partition_with_Consistent_Hashing">Ranged Partition with Consistent Hashing</h3><p>Rather than use the ranges, you can fix your keys and plug in your own hash algorithm to resolve the partition.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">Service</span> <span class="attribute">Name</span>=<span class="value">"TestService"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">StatefulService</span> <span class="attribute">ServiceTypeName</span>=<span class="value">"TestServiceType"</span> </span><br><span class="line">                   <span class="attribute">TargetReplicaSetSize</span>=<span class="value">"3"</span> </span><br><span class="line">                   <span class="attribute">MinReplicaSetSize</span>=<span class="value">"2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">UniformInt64Partition</span> <span class="attribute">PartitionCount</span>=<span class="value">"26"</span> </span><br><span class="line">                           <span class="attribute">LowKey</span>=<span class="value">"0"</span> </span><br><span class="line">                           <span class="attribute">HighKey</span>=<span class="value">"25"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">StatefulService</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">Service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>We now have a key range limited to 0-25 rather than the entire <code>Int64</code> range. We can resolve a client connected to this partition in the same way, however this time we need to compute a key that fits in this smaller range. I’m using the jump consistent hash implementation in <a href="https://github.com/turowicz/Hydra" target="_blank" rel="external">hydra</a>.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> shard = <span class="keyword">new</span> JumpSharding().GetShard(<span class="keyword">value</span>, <span class="number">26</span>);</span><br><span class="line"><span class="keyword">var</span> client = ServiceProxy.Create&lt;ITestService&gt;(</span><br><span class="line">                    shard, </span><br><span class="line">                    <span class="keyword">new</span> Uri(<span class="string">"fabric:/App/TestService"</span>))</span><br></pre></td></tr></table></figure>
<ol>
<li>Call get shard with the value and number of partitions to distribute across.</li>
<li>Create the client with the calculated key to connect to the service on that partition.</li>
</ol>
<h3 id="Distribution">Distribution</h3><p>To benchmark the distribution we have a list of around 17000 real email addresses. This should give us an idea of how the sharding strategies will distribute the data across 26 partitions. Another advantage of using one of the <code>Int64</code> methods is that they can be used with any amount of partitions.</p>
<p>We are looking for an even number of accounts allocated to each partition.</p>
<chart type="BarChart" options="{'title':'Email accounts distribution comparison','vAxis':{'title':'Partitions'},'legend':{'position':'bottom'}, 'height':'750'}"><br>  <div></div><br></chart>

<table>
<thead>
<tr>
<th>Partition</th>
<th>Alphabet</th>
<th>Consistent Hash</th>
<th>Ranging</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1569</td>
<td>684</td>
<td>650</td>
</tr>
<tr>
<td>1</td>
<td>912</td>
<td>682</td>
<td>730</td>
</tr>
<tr>
<td>2</td>
<td>1027</td>
<td>647</td>
<td>646</td>
</tr>
<tr>
<td>3</td>
<td>1175</td>
<td>662</td>
<td>701</td>
</tr>
<tr>
<td>4</td>
<td>513</td>
<td>687</td>
<td>700</td>
</tr>
<tr>
<td>5</td>
<td>415</td>
<td>665</td>
<td>658</td>
</tr>
<tr>
<td>6</td>
<td>581</td>
<td>653</td>
<td>684</td>
</tr>
<tr>
<td>7</td>
<td>466</td>
<td>693</td>
<td>637</td>
</tr>
<tr>
<td>8</td>
<td>405</td>
<td>657</td>
<td>690</td>
</tr>
<tr>
<td>9</td>
<td>1714</td>
<td>681</td>
<td>699</td>
</tr>
<tr>
<td>10</td>
<td>643</td>
<td>654</td>
<td>669</td>
</tr>
<tr>
<td>11</td>
<td>608</td>
<td>696</td>
<td>681</td>
</tr>
<tr>
<td>12</td>
<td>1800</td>
<td>734</td>
<td>665</td>
</tr>
<tr>
<td>13</td>
<td>526</td>
<td>717</td>
<td>647</td>
</tr>
<tr>
<td>14</td>
<td>213</td>
<td>693</td>
<td>613</td>
</tr>
<tr>
<td>15</td>
<td>793</td>
<td>693</td>
<td>676</td>
</tr>
<tr>
<td>16</td>
<td>31</td>
<td>654</td>
<td>683</td>
</tr>
<tr>
<td>17</td>
<td>1039</td>
<td>681</td>
<td>713</td>
</tr>
<tr>
<td>18</td>
<td>1562</td>
<td>661</td>
<td>665</td>
</tr>
<tr>
<td>19</td>
<td>803</td>
<td>708</td>
<td>747</td>
</tr>
<tr>
<td>20</td>
<td>46</td>
<td>653</td>
<td>709</td>
</tr>
<tr>
<td>21</td>
<td>268</td>
<td>693</td>
<td>666</td>
</tr>
<tr>
<td>22</td>
<td>301</td>
<td>678</td>
<td>679</td>
</tr>
<tr>
<td>23</td>
<td>55</td>
<td>702</td>
<td>675</td>
</tr>
<tr>
<td>24</td>
<td>134</td>
<td>670</td>
<td>708</td>
</tr>
<tr>
<td>25</td>
<td>136</td>
<td>737</td>
<td>744</td>
</tr>
</tbody>
</table>
<p>We can see from those results that sharding using the first character of an email produces wildly different partition sizes, not what we want! Both the jump hash and integer ranging methods produced very even parition sizes.</p>
<h3 id="Conclusion">Conclusion</h3><p>Based on these results I would use the ranged partitioning method, it produces provides good balancing and is fast to compute. An additional advantage is you do not need to know the partition count in the code, just map your data to an <code>Int64</code> and service fabric will do the rest. </p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Service fabric gives you two mechanisms out of the box when resolving which partition you hit when calling a Reliable Service. We’ll igno]]>
    </summary>
    
      <category term=".NET" scheme="http://naeem.khedarun.co.uk/blog/tags/NET/"/>
    
      <category term="C#" scheme="http://naeem.khedarun.co.uk/blog/tags/C/"/>
    
      <category term="azure" scheme="http://naeem.khedarun.co.uk/blog/tags/azure/"/>
    
      <category term="servicefabric" scheme="http://naeem.khedarun.co.uk/blog/tags/servicefabric/"/>
    
      <category term="development" scheme="http://naeem.khedarun.co.uk/blog/categories/development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Logging all unhandled exceptions in .NET]]></title>
    <link href="http://naeem.khedarun.co.uk/blog/2016/01/05/logging-all-unhandled-exceptions-in-dotnet-1452008814097/"/>
    <id>http://naeem.khedarun.co.uk/blog/2016/01/05/logging-all-unhandled-exceptions-in-dotnet-1452008814097/</id>
    <published>2016-01-05T15:46:54.000Z</published>
    <updated>2016-01-09T18:33:06.000Z</updated>
    <content type="html"><![CDATA[<p>With most applications its easy to get started on logging.</p>
<ul>
<li>Install a logging framework like NLog or log4net.</li>
<li>Put try catches around your main program logic and include contextual information with the exception.</li>
<li>If its a web application use a logging middleware for your web framework.</li>
</ul>
<p>However this will not log unhandled exceptions from places you couldn’t forsee. So let’s log these just in case anything goes wrong.</p>
<p>Any exceptions which crash the application can be handled using the <code>UnhandledException</code> event.</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">AppDomain.CurrentDomain.UnhandledException += (sender, args) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    Log.Exception((Exception)args.ExceptionObject);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>This will help you diagnose fatal errors. Unfortunately not all exceptions are fatal, and if you have any timers, unawaited async or unhandled task pool exceptions these can cause your application to behave unexpectedly without you knowing about it.</p>
<p>You can use the UnobservedTaskException to catch some of those ones:</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">TaskScheduler.UnobservedTaskException += (sender, args) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!args.Observed)</span><br><span class="line">    &#123;</span><br><span class="line">        Log.Exception(args.Exception);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>If you know any other events or ways to get more of these unexpected errors please let me know!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>With most applications its easy to get started on logging.</p>
<ul>
<li>Install a logging framework like NLog or log4net.</li>
<li>Put tr]]>
    </summary>
    
      <category term=".NET" scheme="http://naeem.khedarun.co.uk/blog/tags/NET/"/>
    
      <category term="C#" scheme="http://naeem.khedarun.co.uk/blog/tags/C/"/>
    
      <category term="development" scheme="http://naeem.khedarun.co.uk/blog/categories/development/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Attaching and formatting drives with Azure ARM and PowerShell]]></title>
    <link href="http://naeem.khedarun.co.uk/blog/2015/12/03/attaching-and-formatting-drives-with-azure-arm-and-powershell/"/>
    <id>http://naeem.khedarun.co.uk/blog/2015/12/03/attaching-and-formatting-drives-with-azure-arm-and-powershell/</id>
    <published>2015-12-03T12:02:16.000Z</published>
    <updated>2015-12-06T17:25:04.000Z</updated>
    <content type="html"><![CDATA[<p>Setting up a virtual machine in Azure using ARM has been made straightforward, even with one-click deployments. If you have any services that need a bigger disk, there are a few more moving parts to get it working. This is based on the <a href="https://github.com/Azure/azure-quickstart-templates/tree/master/windows-vm-custom-script" target="_blank" rel="external">custom script quickstart template</a> and <a href="http://blogs.technet.com/b/heyscriptingguy/archive/2013/05/29/use-powershell-to-initialize-raw-disks-and-partition-and-format-volumes.aspx" target="_blank" rel="external">Ed Wilsons formatting script article</a></p>
<h3 id="Attach_a_disk">Attach a disk</h3><p>To attach a data disk to the virtual machine you can use the following configuration just below the osDisk definition.</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      "<span class="attribute">dataDisks</span>":<span class="value">[&#123;</span><br><span class="line">            "<span class="attribute">lun</span>":<span class="value"><span class="number">0</span></span>,</span><br><span class="line">            "<span class="attribute">name</span>":<span class="value"><span class="string">"datadisk"</span></span>,</span><br><span class="line">            "<span class="attribute">diskSizeGB</span>":<span class="value"><span class="number">1000</span></span>,</span><br><span class="line">            "<span class="attribute">createOption</span>":<span class="value"><span class="string">"Empty"</span></span>,</span><br><span class="line">            "<span class="attribute">vhd</span>":<span class="value">&#123;</span><br><span class="line">                  "<span class="attribute">Uri</span>":<span class="value"><span class="string">"[variables('dataDiskUri')]"</span></span><br><span class="line">            </span>&#125;</span><br><span class="line">      </span>&#125;]</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lun (Logical Unit Number) should be unique for each attached disk and starts from zero.</li>
<li>diskSizeGB has a maximum of 1000 (1 TB) in Azure currently.</li>
<li>createOption should be “Empty” for a new disk.</li>
<li>vhd.Uri is the full path you want the blob created in.</li>
</ul>
<p>If we deployed the template with this now, we will get a raw unformatted disk with no drive label. You can view it in Disk Manager or by running the following PowerShell on the box.</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Get-Disk | Where partitionstyle <span class="operator">-eq</span> <span class="string">'raw'</span></span><br></pre></td></tr></table></figure>
<p>We need one more resource to complete the deployment and give us a formatted disk. We can use the CustomScriptExtension to run a PowerShell script which will format any raw attached disks (in case you want to do multiple drives).</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   "<span class="attribute">type</span>":<span class="value"><span class="string">"Microsoft.Compute/virtualMachines/extensions"</span></span>,</span><br><span class="line">   "<span class="attribute">name</span>":<span class="value"><span class="string">"[concat(variables('vmName'),'/InitialiseDisks')]"</span></span>,</span><br><span class="line">   "<span class="attribute">apiVersion</span>":<span class="value"><span class="string">"2015-05-01-preview"</span></span>,</span><br><span class="line">   "<span class="attribute">location</span>":<span class="value"><span class="string">"[resourceGroup().location]"</span></span>,</span><br><span class="line">   "<span class="attribute">dependsOn</span>":<span class="value">[</span><br><span class="line">      <span class="string">"[concat('Microsoft.Compute/virtualMachines/', variables('vmName'))]"</span></span><br><span class="line">   ]</span>,</span><br><span class="line">   "<span class="attribute">properties</span>":<span class="value">&#123;</span><br><span class="line">      "<span class="attribute">publisher</span>":<span class="value"><span class="string">"Microsoft.Compute"</span></span>,</span><br><span class="line">      "<span class="attribute">type</span>":<span class="value"><span class="string">"CustomScriptExtension"</span></span>,</span><br><span class="line">      "<span class="attribute">typeHandlerVersion</span>":<span class="value"><span class="string">"1.2"</span></span>,</span><br><span class="line">      "<span class="attribute">settings</span>":<span class="value">&#123;</span><br><span class="line">         "<span class="attribute">fileUris</span>":<span class="value">[</span><br><span class="line">            <span class="string">"[variables('initialiseDisksScript')]"</span></span><br><span class="line">         ]</span>,</span><br><span class="line">         "<span class="attribute">commandToExecute</span>":<span class="value"><span class="string">"[concat('powershell -ExecutionPolicy Unrestricted -file ',parameters('scriptName'))]"</span></span><br><span class="line">      </span>&#125;</span><br><span class="line">   </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>dependsOn will need to be the resource path for our virtual machine to ensure this extension is run after its provisioned.</li>
<li>fileUris is an array of any files we want downloaded and made available to execute. <strong>This needs to be a path to an azure blob</strong>, unfortunately you cannot link to any other domains like github.</li>
<li>commandToExecute is a cmd.exe command, so we need to call out to powershell to invoke our script. The working directory will have your downloaded file already there, so you don’t need the full path to execute it, just the name.</li>
</ul>
<p>You will need to upload the following script to a blob:</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">Get-Disk | ` </span><br><span class="line">Where partitionstyle <span class="operator">-eq</span> <span class="string">'raw'</span> | ` </span><br><span class="line">Initialize-Disk -PartitionStyle MBR -PassThru | ` </span><br><span class="line">New-Partition -AssignDriveLetter -UseMaximumSize | ` </span><br><span class="line">Format-Volume -FileSystem NTFS -NewFileSystemLabel <span class="string">"datadisk"</span> -Confirm:<span class="variable">$false</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>Setting up a virtual machine in Azure using ARM has been made straightforward, even with one-click deployments. If you have any services ]]>
    </summary>
    
      <category term="azure" scheme="http://naeem.khedarun.co.uk/blog/tags/azure/"/>
    
      <category term="powershell" scheme="http://naeem.khedarun.co.uk/blog/tags/powershell/"/>
    
      <category term="operations" scheme="http://naeem.khedarun.co.uk/blog/categories/operations/"/>
    
  </entry>
  
</feed>
